# this is the version of YAML we are using with the Kubernetes API
apiVersion: apps/v1
# this kind is the type of Kubernetes resource we are using
# a deployment is when we run code on a server
kind: Deployment
# metadata is information related to the object we created in Kubernetes
metadata:
# the name here is the name of our deployment
  name: stedi-joseph
spec:
# replicas refers to the number of pods we deploy
  replicas: 1
# a selector is a route to my pod
  selector:
# match labels are a label for my selector
    matchLabels:
# app is a specific kind of label for my pod
      app: stedi-joseph
# the template describes all the features of my pod
  template:
# metadata provides labels for my template
    metadata:
      labels:
        app: stedi-joseph
# the spec refers to the specification of my containers in my pod
    spec:
# containers can have one or more Docker containers in the pod
      containers:
# the name of the container is specified below
        - name: stedi-joseph
# the image is a prebuilt file containing the operating system
          image: gcr.io/team-fire262/stedi-joseph
# the ports is a list of tcp ports the pod listens to:
          ports:
# the container port is a specific port the listens on:
          - containerPort: 4567
# resources are the compute resources used by the pod in the cloud
          resources:
# limits represent the max amount of cpu and memory that can be used by the pod
            limits:
# cpu is the max amount of cpu that can be used by the pod
              cpu: ".125"
# memory is the max amount of memory that can be used by the pod
              memory: "500Mi"
# requests is the minimum amount of compute resources used by the pod
            requests:
# cpu is the minimum amount of cpu the pod needs to run
              cpu: ".1"
# memory is the minimum amount of memory the pod needs to run
              memory: "250Mi"
#  livenessprobe is a configuration that checks the pod for health
          livenessProbe:
# httpget instructs kubernetes to do an http request to check health
            httpGet:
# path defines the url to use when doing the http request
              path: /
# port defines the port to use when doing the http request
              port: 4567
# initialdelayseconds tells kubernetes to wait before doing a request
            initialDelaySeconds: 10
# periodSeconds tells Kubernetes how often to check health
            periodSeconds: 3

---
  apiVersion: networking.k8s.io/v1
  kind:
  metadata: 
    name: stedi-ingress-joseph
    annotations:
      kubernetes.io/ingress.global-static-ip-name: stedi-public-joseph
      networking.gke.io/managed-certificates: stedi-certificate-joseph
      kubernetes.io/ingress.allow-http: "false"
      # the below line wasn't there before
      kubernetes.io/ingress.class: "gce"
  spec:
    defaultBackend:   
      service:
        name: stedi-nodeport-joseph
        port:
          number: 80
---
  apiVersion: v1
  kind: Service
  metadata:
    name: stedi-nodeport-joseph
  spec:
    selector:
      app: stedi
    type: NodePort
    ports:
      - port: 80
        targetPort: 4567
---
apiVersion: v1
kind: Service
metadata:
  name: stedi-nodeport-joseph
spec:
  selector:
    app: stedi
  type: NodePort
  ports:
    - port: 80
      targetPort: 4567
---
  apiVersion: networking.gke.io/v1
  kind: ManagedCertificate
  metadata:
    name: stedi-certificate
  spec:
    domains:
      - josephstedi.cit262.com